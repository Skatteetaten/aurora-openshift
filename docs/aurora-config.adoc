== Aurora Config

Aurora Config is an opinoinated way of configuring how namespaces and applications are applied to an OpenShift cluster.

Config files are written either as Json or Yaml. All the examples will use YAML since it is easier on the eyes.


The process for parsing an AuroraConfig is as follows

. find relevant files
. extract and validate header
. extract DeploymentSpec

Extracting is done in a process where the paths from the below tables are matched against the available files. The most specific location is chosen.

=== Dictionary
AuroraConfig: A set of files that share the same schemaVersion and affiliation. Files are either json or yaml. 
LocalTemplate: An AuroraConfig can contain a templates folder with OpenShift template files.
Template: Other templates are referenced from the default namespace in your cluster.
ApplicationId: Indentify an Application. Contains the name of the application and an environment(affiliation and env name)
DeploymentSpec: Result of applying an ApplicationId to a given AuroraConfig


=== Files
[#Files]
Given that you have an application with name 'reference' in the environment 'dev' the following files will be present

Note that the suffix of the file can be either json or yaml
[cols="1,1,2", options="header"]
|===
| filename       | name   | reason
| about.yaml     | global | All applications in a given AuroraConfig will inherit from it
| foo.yaml       | base   | All applications named 'reference' in all environments will inherit from it
| dev.yaml       | env    | All applications in the env 'dev' inhert from it
| dev/foo.yaml   | app    | Instructons on how to deploy the application 'reference' in 'dev'
|===

In order to generate an DeploymentSpec for a given ApplicationId files are read in the order specified above and merged together. 
Information about what file contains what instruction is recorded so that it is possible to get a birds eye view over a DeploymentSpec and where the different instructions come from.

It is possible to change the base and env file in a given app file if you want to compose your configuration.

.utv/reference.yaml
[source,yaml]
----
baseFile: foo.yaml
envFile: about-template.yaml
----

In this scenario 'foo.yaml' would be used instead of 'reference.yaml' as the base file and the 'about-template.yaml' file would be used instead of 'about.yaml'


=== Header
Some instructions are read as a header. This is done in order to provide sane defaults for the rest of the process.

Some of the header fields must be specified in an about file. The environment and permissions must be the same for all applications.

[cols="1,1,2", options="header"]
|=======
|path                            | default      | description
include::fields/header-about.adoc[]
|=======

Other fields can be specified in any file
[cols="1,1,2", options="header"]
|===
|path                            | default      | description
include::fields/header.adoc[]
|===

=== Substitution
Some fields fromt header are available as substitutions when specifying the rest of the configuration

. affiliation
. cluster
. env
. name
. segment

In order to include these into a field surround them with '@'. An example
```
config/cluster : "@cluster@"
```
This will create a config value with the actual value of the cluster.

=== Extracting DeploymentSpec

==== Generate application from Delivery Bundle

If you use the type deploy og development the application objects are generated using a Kotlin DSL from the following fields

[cols="1,1,2", options="header"]
|===
|path                           | default      | description
include::fields/deliveryBundle.adoc[]
|===

==== Generate application from template

If type is template or local template the application objects are generated by applying the template from the following fields.

NB! There will be two parameters VERSION and NAME added to the template automatically.

[cols="1,1,2", options="header"]
|===
|path                           | default      | description
include::fields/template.adoc[]
|===


==== Encrich the application with provisioning NTA resources

[cols="1,1,2", options="header"]
|===
|path                           | default      | description
include::fields/ntaProvisioning.adoc[]
|===

NTA har the following technlogies that can be automated with the above fields
 - Webseal is used for client trafic from within NTA to reach an application. Internal tax workers have roles that can be added to limit who can access the application
 - STS certificate: An SSL certificate with a given commonName is used to identify applications to secure trafic between them
 - Oracle Databases: We haven a DBH-api that expose functionality to auto provision a Oracle schema on a shared server. The API can also handle manual SQL connections for you so the application can get the crendentials in one way
 - BigIP: In order for external consumer trafic to hit an application BigIP must be automated to send the trafic to the cluster.

==== Exposing an application via HTTP
The default behavior is that the application is only visible to other application in the same namespace using
its server name.

In order to control routes into the application the following fields can be used.

[cols="1,1,2", options="header"]
|===
|path                           | default      | description
include::fields/route.adoc[]
|===


=== Example configuration


==== Simple reference-application
Below is an example of how you could configure an instance of the https://github.com/skatteetaten/openshift-reference-springboot-server[reference application]

.about.yaml
[source,yaml]
----
include::auroraConfig/about.yaml[]
----


.reference.yaml
[source,yaml]
----
include::auroraConfig/reference.yaml[]
----

.dev/about/reference.yaml
[source,yaml]
----
include::auroraConfig/dev/about.yaml[]
----

.dev/about/reference.yaml
[source,yaml]
----
include::auroraConfig/dev/reference.yaml[]
----

The complete config is then evaluated as
[source,yaml]
----
include::auroraConfig/reference-full.yaml[]
----
