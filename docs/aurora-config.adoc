== Aurora Config

Aurora Config is an opinoinated way of configuring how namespaces and applications are applied to an OpenShift cluster. 

Config files are written either as Json or Yaml. All the examples will use YAML since it is easier on the eyes. 


=== How is AuroraConfig parsed
. given an ApplicationId determine what files to use. See anchor:Files[]
. extract and validate the DeploymentSpecHeader from the given files using the HeaderMapper See anchor:Header[]
. extract and validate DeploymentSpec from the FieldMappers.
.. different fieldMappers are used for the different types
. generate objects according to the type field.
.. for deploy and development the generate process uses an DSL in Kotlin to generate the objects
.. for tempalte and localTemplate a template is applied
. enrich the generate objects with information from the DeploymentSpec
. the objects are created/updated in the cluster
.. note that this process does not use 'oc apply' on the objects. The state in the cluster is overwritten.


=== Dictionary
AuroraConfig: A set of files that share the same schemaVersion and affiliation. Files are either json or yaml. 
LocalTemplate: An AuroraConfig can contain a templates folder with OpenShift template files.
Template: Other templates are referenced from the default namespace in your cluster.
ApplicationId: Indentify an Application. Contains the name of the application and an environment(affiliation and env name)
DeploymentSpec: Result of applying an ApplicationId to a given AuroraConfig

=== Files
[#Files]
Given that you have an application with name 'reference' in the environment 'dev' the following files will be present

Note that the suffix of the file can be either json or yaml
[cols="1,1,2", options="header"]
|===
| filename       | name   | reason
| about.yaml     | global | All applications in a given AuroraConfig will inherit from it
| foo.yaml       | base   | All applications named 'reference' in all environments will inherit from it
| dev.yaml       | env    | All applications in the env 'dev' inhert from it
| dev/foo.yaml   | app    | Instructons on how to deploy the application 'reference' in 'dev'
|===

In order to generate an DeploymentSpec for a given ApplicationId files are read in the order specified above and merged together. 
Information about what file contains what instruction is recorded so that it is possible to get a birds eye view over a DeploymentSpec and where the different instructions come from.

It is possible to change the base and env file in a given app file if you want to compose your configuration.

.utv/reference.yaml
[source,yaml]
----
baseFile: foo.yaml
envFile: about-template.yaml
----

In this scenario 'foo.yaml' would be used instead of 'reference.yaml' as the base file and the 'about-template.yaml' file would be used instead of 'about.yaml'

=== Header
Some instructions are read as a header. This is done in order to provide sane defaults for the rest of the process.

Some of the header fields must be specified in an about file. The environment and permissions must be the same for all applications.

[cols="1,1,2", options="header"]
|=======
|path                            | default      | description
include::fields/header-about.adoc[]
|=======

Other fields can be specified in any filel
[cols="1,1,2", options="header"]
|===
|path                            | default      | description
include::fields/header.adoc[]
|===

==== The type field
AuroraConfig has a type field that determine what workflow that should be used when applying an DeploymentSpec to the cluster.

The current types are available
 - Deploy: Deploy a pre build image in a namespace. 
 - Development: Set up an application in an environment that can be built using the provided BuildConfig. Using binary builds for local development is the most used here
 - Template: Deploy an template from the OpenShift cluster in a namespace
 - LocalTemplate: Deploy an template from the templates folder of the AuroraConfig

TODO: Templates should require a VERSION field if you want to change version in AuroraConsole
TODO: Templates shoudl require a NAME field that will be prefix of all objects generated


=== Extracting DeploymentSpec

==== Provisioning resources for NTA

[cols="1,1,2", options="header"]
|===
|path                           | default      | description
include::fields/ntaProvisioning.adoc[]
|===

TODO: Add bigIp

==== Generate application from Delivery Bundle

If you use the type deploy og development the application objects are generated using a Kotlin DSL from the following fields

[cols="1,1,2", options="header"]
|===
|path                           | default      | description
include::fields/deliveryBundle.adoc[]
|===

==== Generate application from template

[cols="1,1,2", options="header"]
|===
|path                           | default      | description
include::fields/template.adoc[]
|===


==== Exposing an application via HTTP
The default behavior is that the application is only visible to other application in the same namespace using
its server name.

In order to control routes into the application the following fields can be used

[cols="1,1,2", options="header"]
|===
|path                           | default      | description
include::fields/route.adoc[]
|===

=== AuroraConfig fields

[cols="1,1,2", options="header"]
|===
|path                           | default      | description

|===

=== Example configuration for the reference-application
Below is an example of how you could configure an instance of the https://github.com/skatteetaten/openshift-reference-springboot-server[reference application]

.about.yaml
[source,yaml]
----
include::auroraConfig/about.yaml[]
----


.reference.yaml
[source,yaml]
----
include::auroraConfig/reference.yaml[]
----

.dev/about/reference.yaml
[source,yaml]
----
include::auroraConfig/dev/about.yaml[]
----

.dev/about/reference.yaml
[source,yaml]
----
include::auroraConfig/dev/reference.yaml[]
----

The complete config is then evaluated as
[source,yaml]
----
include::auroraConfig/reference-full.yaml[]
----